#!/usr/bin/env python
# -*- coding: utf-8 -*-

########################################################################
#                                                                      #
#      Copyright (©) Cerema/DTerSO/AT/OSECC - All rights reserved      #
#                                                                      #
########################################################################

'''
Nom de l'objet : UhiVulnerability.py
Description :
    Objectif : calcul d'indicateurs de vulnérabilité au phénomène d'ICU

-----------------
Outils utilisés :
 - PostGIS

------------------------------
Historique des modifications :
 - 22/03/2021 : création

-----------------------
A réfléchir / A faire :
 - implémenter la vulnérabilité liée au bâti
'''

# Import des bibliothèques Python
from __future__ import print_function
import os, sys, argparse
from Lib_display import bold,red,green,yellow,blue,magenta,cyan,endC,displayIHM
from Lib_file import removeVectorFile
from Lib_log import timeLine
from Lib_postgis import createDatabase, importVectorByOgr2ogr, openConnection, executeQuery, closeConnection, exportVectorByOgr2ogr, dropDatabase

# Niveau de debug (variable globale)
debug = 3

########################################################################
# FONCTION populationVulnerability()                                   #
########################################################################
# ROLE :
#     calcul d'indicateurs de vulnérabilité des populations au phénomène d'ICU
#
# ENTREES DE LA FONCTION :
#     input_division : fichier de division géométrique (entrée vecteur)
#     input_footprint : fichier d'emprise de zone d'étude (entrée vecteur)
#     input_population : fichier de données de population (entrée vecteur)
#     input_built : fichier des bâtiments (entrée vecteur)
#     output_vulnerability : fichier d'indicateurs de vulnérabilité (sortie vecteur)
#     id_div : champ identifiant du fichier de division géométrique. Par défaut : 'id'
#     id_pop : champ identifiant du fichier de données de population. Par défaut : 'IdINSPIRE'
#     id_blt : champ identifiant du fichier des bâtiments. Par défaut : 'ID'
#     stake_field : champ enjeux (population totale) du fichier de données de population. Par défaut : 'Ind'
#     health_vuln_field_list : liste des champs de vulnérabilité sanitaire (population à risque) du fichier de données de population. Par défaut : ['Ind_0_3', 'Ind_4_5', 'Ind_65_79', 'Ind_80p']
#     social_vuln_field_list : liste des champs de vulnérabilité sociale (ménages pauvres) du fichier de données de population. Par défaut : ['Men_pauv']
#     height_field : champ hauteur du fichier des bâtiments. Par défaut : 'HAUTEUR'
#     built_sql_filter : filtrage SQL pour le nettoyage du fichier des bâtiments. Par défaut : "NATURE LIKE 'Indiff%renci%e' AND (USAGE1 LIKE 'Indiff%renci%e' OR USAGE1 LIKE 'R%sidentiel' OR USAGE2 LIKE 'R%sidentiel' OR USAGE2 IS NULL) AND HAUTEUR IS NOT NULL AND ST_Area(geom) >= 20"
#     epsg : code epsg du système de projection. Par défaut : 2154
#     format_vector : format des fichiers vecteur. Par défaut : 'ESRI Shapefile'
#     postgis_ip_host : nom du serveur PostGIS. Par défaut : 'localhost'
#     postgis_num_port : numéro de port du serveur PostGIS. Par défaut : 5432
#     postgis_user_name : nom d'utilisateur PostGIS. Par défaut : 'postgres'
#     postgis_password : mot de passe de l'utilisateur PostGIS. Par défaut : 'postgres'
#     postgis_database_name : nom de la base PostGIS. Par défaut : 'uhi_vuln'
#     postgis_schema_name : nom du schéma dans la base PostGIS. Par défaut : 'public'
#     postgis_encoding : l'encodage des fichiers pour l'import de vecteurs dans PostGIS. Par défaut : 'UTF-8'
#     path_time_log : fichier log de sortie, par défaut vide
#     save_results_intermediate : fichiers temporaires conservés, par défaut = False
#     overwrite : écrase si un fichier existant a le même nom qu'un fichier de sortie, par défaut = True
#
# SORTIES DE LA FONCTION :
#     N.A.

def populationVulnerability(input_division, input_footprint, input_population, input_built, output_vulnerability, id_div = 'id', id_pop = 'IdINSPIRE', id_blt = 'ID', stake_field = 'Ind', health_vuln_field_list = ['Ind_0_3', 'Ind_4_5', 'Ind_65_79', 'Ind_80p'], social_vuln_field_list = ['Men_pauv'], height_field = 'HAUTEUR', built_sql_filter = "NATURE LIKE 'Indiff%renci%e' AND (USAGE1 LIKE 'Indiff%renci%e' OR USAGE1 LIKE 'R%sidentiel' OR USAGE2 LIKE 'R%sidentiel' OR USAGE2 IS NULL) AND HAUTEUR IS NOT NULL AND ST_Area(geom) >= 20", epsg=2154, format_vector='ESRI Shapefile', postgis_ip_host='localhost', postgis_num_port=5432, postgis_user_name='postgres', postgis_password='postgres', postgis_database_name='uhi_vuln', postgis_schema_name='public', postgis_encoding='UTF-8', path_time_log='', save_results_intermediate=False, overwrite=True):

    if debug >= 3:
        print('\n' + bold + green + "Vulnérabilité des populations - Variables dans la fonction :" + endC)
        print(cyan + "    populationVulnerability() : " + endC + "input_division : " + str(input_division) + endC)
        print(cyan + "    populationVulnerability() : " + endC + "input_footprint : " + str(input_footprint) + endC)
        print(cyan + "    populationVulnerability() : " + endC + "input_population : " + str(input_population) + endC)
        print(cyan + "    populationVulnerability() : " + endC + "input_built : " + str(input_built) + endC)
        print(cyan + "    populationVulnerability() : " + endC + "output_vulnerability : " + str(output_vulnerability) + endC)
        print(cyan + "    populationVulnerability() : " + endC + "id_div : " + str(id_div) + endC)
        print(cyan + "    populationVulnerability() : " + endC + "id_pop : " + str(id_pop) + endC)
        print(cyan + "    populationVulnerability() : " + endC + "id_blt : " + str(id_blt) + endC)
        print(cyan + "    populationVulnerability() : " + endC + "stake_field : " + str(stake_field) + endC)
        print(cyan + "    populationVulnerability() : " + endC + "health_vuln_field_list : " + str(health_vuln_field_list) + endC)
        print(cyan + "    populationVulnerability() : " + endC + "social_vuln_field_list : " + str(social_vuln_field_list) + endC)
        print(cyan + "    populationVulnerability() : " + endC + "height_field : " + str(height_field) + endC)
        print(cyan + "    populationVulnerability() : " + endC + "built_sql_filter : " + str(built_sql_filter) + endC)
        print(cyan + "    populationVulnerability() : " + endC + "epsg : " + str(epsg) + endC)
        print(cyan + "    populationVulnerability() : " + endC + "format_vector : " + str(format_vector) + endC)
        print(cyan + "    populationVulnerability() : " + endC + "postgis_ip_host : " + str(postgis_ip_host) + endC)
        print(cyan + "    populationVulnerability() : " + endC + "postgis_num_port : " + str(postgis_num_port) + endC)
        print(cyan + "    populationVulnerability() : " + endC + "postgis_user_name : " + str(postgis_user_name) + endC)
        print(cyan + "    populationVulnerability() : " + endC + "postgis_password : " + str(postgis_password) + endC)
        print(cyan + "    populationVulnerability() : " + endC + "postgis_database_name : " + str(postgis_database_name) + endC)
        print(cyan + "    populationVulnerability() : " + endC + "postgis_schema_name : " + str(postgis_schema_name) + endC)
        print(cyan + "    populationVulnerability() : " + endC + "postgis_encoding : " + str(postgis_encoding) + endC)
        print(cyan + "    populationVulnerability() : " + endC + "path_time_log : " + str(path_time_log) + endC)
        print(cyan + "    populationVulnerability() : " + endC + "save_results_intermediate : " + str(save_results_intermediate) + endC)
        print(cyan + "    populationVulnerability() : " + endC + "overwrite : " + str(overwrite) + endC + '\n')

    # Définition des constantes
    PREFIX_STAND = 'S_'
    STAKE_IND_FIELD = 'enjeu'
    HEALTH_VULN_IND_FIELD = 'vuln_san'
    SOCIAL_VULN_IND_FIELD = 'vuln_soc'
    GLOBAL_VULN_IND_FIELD = 'vuln_glo'

    # Mise à jour du log
    starting_event = "populationVulnerability() : Début du traitement : "
    timeLine(path_time_log, starting_event)

    print(cyan + "populationVulnerability() : " + bold + green + "DEBUT DES TRAITEMENTS" + endC + '\n')

    # Définition des variables tables/champs PostGIS
    div_table = 'i_division'
    ftp_table = 'i_footprint'
    pop_table = 'i_population'
    blt_table = 'i_built'
    vuln_table = 'o_vulnerability'
    clean_pop_table = 't_clean_pop'
    clean_blt_table = 't_clean_blt'
    inter_pop_blt_table = 't_inter_pop_blt'
    inter_popblt_div_table = 't_inter_popblt_div'
    div_no_pop_table = 't_div_with_no_pop'
    built_area_field = 'surf_bati'
    floor_area_field = 'surf_habit'
    inter_area_field = 'surf_inter'

    # Définition de variables diverses
    pop_fields_to_treat = [stake_field] + health_vuln_field_list + social_vuln_field_list
    pop_fields_to_keep = [id_pop] + pop_fields_to_treat
    blt_fields_to_keep = [id_blt] + [height_field]
    pop_fields_to_treat_str = stake_field
    for health_vuln_field in health_vuln_field_list:
        pop_fields_to_treat_str += ', ' + health_vuln_field
    for social_vuln_field in social_vuln_field_list:
        pop_fields_to_treat_str += ', ' + social_vuln_field

    # Nettoyage des traitements précédents
    if overwrite:
        if debug >= 3:
            print(cyan + "populationVulnerability() : " + endC + "Nettoyage des traitements précédents." + endC + '\n')
        removeVectorFile(output_vulnerability, format_vector=format_vector)
        dropDatabase(postgis_database_name, user_name=postgis_user_name, password=postgis_password, ip_host=postgis_ip_host, num_port=postgis_num_port, schema_name=postgis_schema_name)
    else:
        if os.path.exists(output_vulnerability):
            print(cyan + "populationVulnerability() : " + bold + yellow + "Le fichier de sortie existe déjà et ne sera pas regénéré." + endC + '\n')
            raise
        pass

    ####################################################################

    #############
    # Etape 1/5 # Préparation de la base de données PostGIS
    #############

    print(cyan + "populationVulnerability() : " + bold + green + "ETAPE 1/5 - Début de la préparation de la base de données PostGIS." + endC + '\n')

    createDatabase(postgis_database_name, user_name=postgis_user_name, password=postgis_password, ip_host=postgis_ip_host, num_port=postgis_num_port, schema_name=postgis_schema_name)
    div_table = importVectorByOgr2ogr(postgis_database_name, input_division, div_table, user_name=postgis_user_name, password=postgis_password, ip_host=postgis_ip_host, num_port=postgis_num_port, schema_name=postgis_schema_name, epsg=epsg, codage=postgis_encoding)
    ftp_table = importVectorByOgr2ogr(postgis_database_name, input_footprint, ftp_table, user_name=postgis_user_name, password=postgis_password, ip_host=postgis_ip_host, num_port=postgis_num_port, schema_name=postgis_schema_name, epsg=epsg, codage=postgis_encoding)
    pop_table = importVectorByOgr2ogr(postgis_database_name, input_population, pop_table, user_name=postgis_user_name, password=postgis_password, ip_host=postgis_ip_host, num_port=postgis_num_port, schema_name=postgis_schema_name, epsg=epsg, codage=postgis_encoding)
    blt_table = importVectorByOgr2ogr(postgis_database_name, input_built, blt_table, user_name=postgis_user_name, password=postgis_password, ip_host=postgis_ip_host, num_port=postgis_num_port, schema_name=postgis_schema_name, epsg=epsg, codage=postgis_encoding)
    connection = openConnection(postgis_database_name, user_name=postgis_user_name, password=postgis_password, ip_host=postgis_ip_host, num_port=postgis_num_port, schema_name=postgis_schema_name)
    cursor = connection.cursor()
    query = "CREATE INDEX IF NOT EXISTS %s_geom_gist ON %s USING GIST (geom);\n" % (div_table, div_table)
    query += "CREATE INDEX IF NOT EXISTS %s_geom_gist ON %s USING GIST (geom);\n" % (ftp_table, ftp_table)
    query += "CREATE INDEX IF NOT EXISTS %s_geom_gist ON %s USING GIST (geom);\n" % (pop_table, pop_table)
    query += "CREATE INDEX IF NOT EXISTS %s_geom_gist ON %s USING GIST (geom);\n" % (blt_table, blt_table)
    if debug >= 3:
        print(query)
    executeQuery(connection, query)

    print(cyan + "populationVulnerability() : " + bold + green + "ETAPE 1/5 - Fin de la préparation de la base de données PostGIS." + endC + '\n')

    #############
    # Etape 2/5 # Préparation des données
    #############

    print(cyan + "populationVulnerability() : " + bold + green + "ETAPE 2/5 - Début de la préparation des données." + endC + '\n')

    # Préparation donnée bâti = sélection à la zone d'étude + suppression du bâti non-habitation + MAJ champ hauteur + ajout champ surface habitable
    select_query = ""
    for blt_field in blt_fields_to_keep:
        select_query += "b.%s, " % blt_field
    query = "DROP TABLE IF EXISTS %s;\n" % clean_blt_table
    query += "CREATE TABLE %s AS\n" % clean_blt_table
    query += "    SELECT %s, b.geom\n" % select_query[:-2]
    query += "    FROM (\n"
    query += "        SELECT *\n"
    query += "        FROM %s\n" % blt_table
    query += "        WHERE %s\n" % built_sql_filter
    query += "        ) AS b, %s AS f\n" % ftp_table
    query += "    WHERE ST_Intersects(b.geom, f.geom);\n"
    query += "CREATE INDEX IF NOT EXISTS %s_geom_gist ON %s USING GIST (geom);\n" % (clean_blt_table, clean_blt_table)
    query += "UPDATE %s SET %s = 3 WHERE %s < 3;\n" % (clean_blt_table, height_field, height_field)
    query += "ALTER TABLE %s ADD COLUMN %s NUMERIC(12,6);\n" % (clean_blt_table, built_area_field)
    query += "UPDATE %s SET %s = ST_Area(geom);\n" % (clean_blt_table, built_area_field)
    query += "ALTER TABLE %s ADD COLUMN %s NUMERIC(12,6);\n" % (clean_blt_table, floor_area_field)
    query += "UPDATE %s SET %s = ((%s * %s) / 3);\n" % (clean_blt_table, floor_area_field, height_field, built_area_field)
    if debug >= 3:
        print(query)
    executeQuery(connection, query)
    blt_fields_to_keep.append(built_area_field)
    blt_fields_to_keep.append(floor_area_field)

    # Préparation donnée population = sélection à la zone d'étude + nettoyage de champs
    select_query = ""
    for pop_field in pop_fields_to_keep:
        select_query += "p.%s, " % pop_field
    query = "DROP TABLE IF EXISTS %s;\n" % clean_pop_table
    query += "CREATE TABLE %s AS\n" % clean_pop_table
    query += "    SELECT %s, p.geom\n" % select_query[:-2]
    query += "    FROM %s AS p, %s AS f\n" % (pop_table, ftp_table)
    query += "    WHERE ST_Intersects(p.geom, f.geom);\n"
    query += "CREATE INDEX IF NOT EXISTS %s_geom_gist ON %s USING GIST (geom);\n" % (clean_pop_table, clean_pop_table)
    if debug >= 3:
        print(query)
    executeQuery(connection, query)

    print(cyan + "populationVulnerability() : " + bold + green + "ETAPE 2/5 - Fin de la préparation des données." + endC + '\n')

    #############
    # Etape 3/5 # Intersect de données
    #############

    print(cyan + "populationVulnerability() : " + bold + green + "ETAPE 3/5 - Début de l'intersect de données." + endC + '\n')

    # Calcul du prorata de population par bâtiment
    select_query = ""
    for blt_field in blt_fields_to_keep:
        select_query += "b.%s, " % blt_field
    for pop_field in pop_fields_to_keep:
        select_query += "p.%s, " % pop_field
    query = "DROP TABLE IF EXISTS %s;\n" % inter_pop_blt_table
    query += "CREATE TABLE %s AS\n" % inter_pop_blt_table
    query += "    SELECT %s, ST_Intersection(b.geom, p.geom) AS geom\n" % select_query[:-2]
    query += "    FROM %s AS b, %s AS p\n" % (clean_blt_table, clean_pop_table)
    query += "    WHERE ST_Intersects(b.geom, p.geom);\n"
    query += "CREATE INDEX IF NOT EXISTS %s_geom_gist ON %s USING GIST (geom);\n" % (inter_pop_blt_table, inter_pop_blt_table)
    query += "ALTER TABLE %s ADD COLUMN %s NUMERIC(12,6);\n" % (inter_pop_blt_table, inter_area_field)
    query += "UPDATE %s SET %s = ST_Area(geom);\n" % (inter_pop_blt_table, inter_area_field)
    for pop_field in pop_fields_to_treat:
        query += "UPDATE %s SET %s = (%s * (%s / %s));\n" % (inter_pop_blt_table, pop_field, pop_field, inter_area_field, built_area_field)
    if debug >= 3:
        print(query)
    executeQuery(connection, query)

    # Somme de population par polygone division
    select_query = "SUM(i.%s) AS %s, " % (floor_area_field, floor_area_field)
    for pop_field in pop_fields_to_treat:
        select_query += "SUM(i.%s) AS %s, " % (pop_field, pop_field)
    query = "DROP TABLE IF EXISTS %s;\n" % inter_popblt_div_table
    query += "CREATE TABLE %s AS\n" % inter_popblt_div_table
    query += "    SELECT d.%s, %s, d.geom\n" % (id_div, select_query[:-2])
    query += "    FROM %s AS d, %s AS i\n" % (div_table, inter_pop_blt_table)
    query += "    WHERE ST_Intersects(d.geom, i.geom)\n"
    query += "    GROUP BY d.%s, d.geom;\n" % id_div
    query += "CREATE INDEX IF NOT EXISTS %s_geom_gist ON %s USING GIST (geom);\n" % (inter_popblt_div_table, inter_popblt_div_table)
    if debug >= 3:
        print(query)
    executeQuery(connection, query)

    print(cyan + "populationVulnerability() : " + bold + green + "ETAPE 3/5 - Fin de l'intersect de données." + endC + '\n')

    #############
    # Etape 4/5 # Préparation du fichier final
    #############

    print(cyan + "populationVulnerability() : " + bold + green + "ETAPE 4/5 - Début de la préparation du fichier final." + endC + '\n')

    # Nouvelle table avec les géométries sans données population
    query = "DROP TABLE IF EXISTS %s;\n" % div_no_pop_table
    query += "CREATE TABLE %s AS\n" % div_no_pop_table
    query += "    SELECT DISTINCT %s, geom\n" % id_div
    query += "    FROM %s\n" % div_table
    query += "    WHERE %s NOT IN\n" % id_div
    query += "        (SELECT DISTINCT %s\n" % id_div
    query += "        FROM %s);\n" % inter_popblt_div_table
    query += "CREATE INDEX IF NOT EXISTS %s_geom_gist ON %s USING GIST (geom);\n" % (div_no_pop_table, div_no_pop_table)
    query += "ALTER TABLE %s ADD COLUMN %s NUMERIC(12,6) DEFAULT 0;\n" % (div_no_pop_table, floor_area_field)
    for pop_field in pop_fields_to_treat:
        query += "ALTER TABLE %s ADD COLUMN %s NUMERIC(8,6) DEFAULT 0;\n" % (div_no_pop_table, pop_field)
    if debug >= 3:
        print(query)
    executeQuery(connection, query)

    # Union de tables pour reconstituer la table finale
    query = "DROP TABLE IF EXISTS %s;\n" % vuln_table
    query += "CREATE TABLE %s AS\n" % vuln_table
    query += "    SELECT %s, %s, %s, geom\n" % (id_div, floor_area_field, pop_fields_to_treat_str)
    query += "    FROM %s\n" % inter_popblt_div_table
    query += "    UNION\n"
    query += "    SELECT %s, %s, %s, geom\n" % (id_div, floor_area_field, pop_fields_to_treat_str)
    query += "    FROM %s;\n" % div_no_pop_table
    query += "CREATE INDEX IF NOT EXISTS %s_geom_gist ON %s USING GIST (geom);\n" % (vuln_table, vuln_table)
    if debug >= 3:
        print(query)
    executeQuery(connection, query)

    # Standardisation des données
    for pop_field in pop_fields_to_treat:
        pop_stand_field = PREFIX_STAND + pop_field[:8]
        cursor.execute("SELECT min(%s) FROM %s;" % (pop_field, vuln_table))
        min_value = cursor.fetchone()
        cursor.execute("SELECT max(%s) FROM %s;" % (pop_field, vuln_table))
        max_value = cursor.fetchone()
        pop_stand_calc = "((%s - %s) / (%s - %s))" % (pop_field, min_value[0], max_value[0], min_value[0])
        query = "ALTER TABLE %s ADD COLUMN %s NUMERIC(8,6);\n" % (vuln_table, pop_stand_field)
        query += "UPDATE %s SET %s = %s;\n" % (vuln_table, pop_stand_field, pop_stand_calc)
        if debug >= 3:
            print(query)
        executeQuery(connection, query)

    print(cyan + "populationVulnerability() : " + bold + green + "ETAPE 4/5 - préparation du fichier final." + endC + '\n')

    #############
    # Etape 5/5 # Calcul des indicateurs
    #############

    print(cyan + "populationVulnerability() : " + bold + green + "ETAPE 5/5 - Début du calcul des indicateurs." + endC + '\n')

    # Calcul indice enjeu
    stake_stand_field = PREFIX_STAND + stake_field[:8]
    cursor.execute("SELECT max(%s) FROM %s;" % (stake_stand_field, vuln_table))
    max_enjeu = cursor.fetchone()
    query = "ALTER TABLE %s ADD COLUMN %s NUMERIC(8,6);\n" % (vuln_table, STAKE_IND_FIELD)
    query += "UPDATE %s SET %s = (%s / %s);\n" % (vuln_table, STAKE_IND_FIELD, stake_stand_field, max_enjeu[0])
    if debug >= 3:
        print(query)
    executeQuery(connection, query)

    # Indice de vulnérabilité sanitaire
    health_vuln_pop_sum = ""
    for health_vuln_field in health_vuln_field_list:
        pop_stand_field = PREFIX_STAND + health_vuln_field[:8]
        health_vuln_pop_sum += "%s + " % pop_stand_field
    health_vuln_pop_sum = health_vuln_pop_sum[:-3]
    cursor.execute("SELECT max(%s) FROM %s;" % (health_vuln_pop_sum, vuln_table))
    max_health_vuln_pop_sum = cursor.fetchone()
    query = "ALTER TABLE %s ADD COLUMN %s NUMERIC(8,6);\n" % (vuln_table, HEALTH_VULN_IND_FIELD)
    query += "UPDATE %s SET %s = ((%s) / %s);\n" % (vuln_table, HEALTH_VULN_IND_FIELD, health_vuln_pop_sum, max_health_vuln_pop_sum[0])
    if debug >= 3:
        print(query)
    executeQuery(connection, query)

    # Indice de vulnérabilité sociale
    social_vuln_pop_sum = ""
    for social_vuln_field in social_vuln_field_list:
        pop_stand_field = PREFIX_STAND + social_vuln_field[:8]
        social_vuln_pop_sum += "%s + " % pop_stand_field
    social_vuln_pop_sum = social_vuln_pop_sum[:-3]
    cursor.execute("SELECT max(%s) FROM %s;" % (social_vuln_pop_sum, vuln_table))
    max_social_vuln_pop_sum = cursor.fetchone()
    query = "ALTER TABLE %s ADD COLUMN %s NUMERIC(8,6);\n" % (vuln_table, SOCIAL_VULN_IND_FIELD)
    query += "UPDATE %s SET %s = ((%s) / %s);\n" % (vuln_table, SOCIAL_VULN_IND_FIELD, social_vuln_pop_sum, max_social_vuln_pop_sum[0])
    if debug >= 3:
        print(query)
    executeQuery(connection, query)

    # Indice de vulnérabilité globale
    cursor.execute("SELECT max(%s + %s) FROM %s;" % (HEALTH_VULN_IND_FIELD, SOCIAL_VULN_IND_FIELD, vuln_table))
    max_pop_vuln_glo_sum = cursor.fetchone()
    query = "ALTER TABLE %s ADD COLUMN %s NUMERIC(8,6);\n" % (vuln_table, GLOBAL_VULN_IND_FIELD)
    query += "UPDATE %s SET %s = ((%s + %s) / %s);\n" % (vuln_table, GLOBAL_VULN_IND_FIELD, HEALTH_VULN_IND_FIELD, SOCIAL_VULN_IND_FIELD, max_pop_vuln_glo_sum[0])
    if debug >= 3:
        print(query)
    executeQuery(connection, query)

    print(cyan + "populationVulnerability() : " + bold + green + "ETAPE 5/5 - Fin du calcul des indicateurs." + endC + '\n')

    closeConnection(connection)
    exportVectorByOgr2ogr(postgis_database_name, output_vulnerability, vuln_table, user_name=postgis_user_name, password=postgis_password, ip_host=postgis_ip_host, num_port=postgis_num_port, schema_name=postgis_schema_name, format_type=format_vector)

    ####################################################################

    # Suppression des fichiers temporaires
    if not save_results_intermediate:
        if debug >= 3:
            print(cyan + "populationVulnerability() : " + endC + "Suppression des fichiers temporaires." + endC + '\n')
        dropDatabase(postgis_database_name, user_name=postgis_user_name, password=postgis_password, ip_host=postgis_ip_host, num_port=postgis_num_port, schema_name=postgis_schema_name)

    print(cyan + "populationVulnerability() : " + bold + green + "FIN DES TRAITEMENTS" + endC + '\n')

    # Mise à jour du log
    ending_event = "populationVulnerability() : Fin du traitement : "
    timeLine(path_time_log, ending_event)

    return 0

#############################################################################################################################
################################################## Mise en place du parser ##################################################
#############################################################################################################################

def main(gui=False):
    parser = argparse.ArgumentParser(prog = "Vulnérabilité ICU", description = "\
    Calcul d'indicateurs de vulnérabilité au phénomène d'Îlot de Chaleur Urbain. \n\
    Exemple : python3 -m UhiVulnerability -div /mnt/RAM_disk/segmentation_urbaine.shp \n\
                                          -ftp /mnt/RAM_disk/zone_etude.shp \n\
                                          -pop /mnt/RAM_disk/population.shp \n\
                                          -blt /mnt/RAM_disk/bati.shp \n\
                                          -out /mnt/RAM_disk/indices_vulnerabilite.shp")

    parser.add_argument('-div', '--input_division', default="", type=str, required=True, help="Input geometric division vector file.")
    parser.add_argument('-ftp', '--input_footprint', default="", type=str, required=True, help="Input area study footprint vector file.")
    parser.add_argument('-pop', '--input_population', default="", type=str, required=True, help="Input population data vector file.")
    parser.add_argument('-blt', '--input_built', default="", type=str, required=True, help="Input built vector file.")
    parser.add_argument('-out', '--output_vulnerability', default="", type=str, required=True, help="Output UHI vulnerability indicators vector file.")
    parser.add_argument('-idd', '--id_div', default="id", type=str, required=False, help="ID field of geometric division file. Default: 'id'.")
    parser.add_argument('-idp', '--id_pop', default="IdINSPIRE", type=str, required=False, help="ID field of population data file. Default: 'IdINSPIRE'.")
    parser.add_argument('-idb', '--id_blt', default="ID", type=str, required=False, help="ID field of built file. Default: 'ID'.")
    parser.add_argument('-sta', '--stake_field', default="Ind", type=str, required=False, help="Stake field of population data file. Default: 'Ind'.")
    parser.add_argument('-hevl', '--health_vuln_field_list', nargs="+", default=['Ind_0_3', 'Ind_4_5', 'Ind_65_79', 'Ind_80p'], type=str, required=False, help="List of health vulnerability fields of population data file. Default: 'Ind_0_3 Ind_4_5 Ind_65_79 Ind_80p'.")
    parser.add_argument('-sovl', '--social_vuln_field_list', nargs="+", default=['Men_pauv'], type=str, required=False, help="List of social vulnerability fields of population data file. Default: 'Men_pauv'.")
    parser.add_argument('-hei', '--height_field', default="HAUTEUR", type=str, required=False, help="Height field of built file. Default: 'HAUTEUR'.")
    parser.add_argument('-bsf', '--built_sql_filter', default="NATURE LIKE 'Indiff%renci%e' AND (USAGE1 LIKE 'Indiff%renci%e' OR USAGE1 LIKE 'R%sidentiel' OR USAGE2 LIKE 'R%sidentiel' OR USAGE2 IS NULL) AND HAUTEUR IS NOT NULL AND ST_Area(geom) >= 20", type=str, required=False, help="SQL filter to clean built file. Default: \"NATURE LIKE 'Indiff%%renci%%e' AND (USAGE1 LIKE 'Indiff%%renci%%e' OR USAGE1 LIKE 'R%%sidentiel' OR USAGE2 LIKE 'R%%sidentiel' OR USAGE2 IS NULL) AND HAUTEUR IS NOT NULL AND ST_Area(geom) >= 20\".")
    parser.add_argument('-epsg', '--epsg', default=2154, type=int, required=False, help="Projection of the output file. Default: 2154.")
    parser.add_argument('-vef', '--format_vector', default="ESRI Shapefile", type=str, required=False, help="Format of vector files. Default: 'ESRI Shapefile'.")
    parser.add_argument('-pgh', '--postgis_ip_host', default="localhost", type=str, required=False, help="PostGIS server name or IP adress. Default: 'localhost'.")
    parser.add_argument('-pgp', '--postgis_num_port', default=5432, type=int, required=False, help="PostGIS port number. Default: '5432'.")
    parser.add_argument('-pgu', '--postgis_user_name', default="postgres", type=str, required=False, help="PostGIS user name. Default: 'postgres'.")
    parser.add_argument('-pgw', '--postgis_password', default="postgres", type=str, required=False, help="PostGIS user password. Default: 'postgres'.")
    parser.add_argument('-pgd', '--postgis_database_name', default="uhi_vuln", type=str, required=False, help="PostGIS database name. Default: 'database'.")
    parser.add_argument('-pgs', '--postgis_schema_name', default="public", type=str, required=False, help="PostGIS schema name. Default: 'public'.")
    parser.add_argument('-pge', '--postgis_encoding', default="UTF-8", type=str, required=False, help="PostGIS encoding for vector import. Default: 'UTF-8'.")
    parser.add_argument('-log', '--path_time_log', default="", type=str, required=False, help="Option: Name of log. Default, no log file.")
    parser.add_argument('-sav', '--save_results_intermediate', action='store_true', default=False, required=False, help="Option: Save intermediate result after the process. Default, False.")
    parser.add_argument('-now', '--overwrite', action='store_false', default=True, required=False, help="Option: Overwrite files with same names. Default, True.")
    parser.add_argument('-debug', '--debug', default=3, type=int, required=False, help="Option: Value of level debug trace. Default, 3.")
    args = displayIHM(gui, parser)

    # Récupération des fichiers d'entrée
    if args.input_division != None:
        input_division = args.input_division
        if not os.path.isfile(input_division):
            raise NameError (cyan + "UhiVulnerability: " + bold + red  + "File %s not exists (input_division)." % input_division + endC)
    if args.input_footprint != None:
        input_footprint = args.input_footprint
        if not os.path.isfile(input_footprint):
            raise NameError (cyan + "UhiVulnerability: " + bold + red  + "File %s not exists (input_footprint)." % input_footprint + endC)
    if args.input_population != None:
        input_population = args.input_population
        if not os.path.isfile(input_population):
            raise NameError (cyan + "UhiVulnerability: " + bold + red  + "File %s not exists (input_population)." % input_population + endC)
    if args.input_built != None:
        input_built = args.input_built
        if not os.path.isfile(input_built):
            raise NameError (cyan + "UhiVulnerability: " + bold + red  + "File %s not exists (input_built)." % input_built + endC)

    # Récupération du fichier de sortie
    if args.output_vulnerability != None:
        output_vulnerability = args.output_vulnerability

    # Récupération des paramètres spécifiques
    if args.id_div != None:
        id_div = args.id_div
    if args.id_pop != None:
        id_pop = args.id_pop
    if args.id_blt != None:
        id_blt = args.id_blt
    if args.stake_field != None:
        stake_field = args.stake_field
    if args.health_vuln_field_list != None:
        health_vuln_field_list = args.health_vuln_field_list
    if args.social_vuln_field_list != None:
        social_vuln_field_list = args.social_vuln_field_list
    if args.height_field != None:
        height_field = args.height_field
    if args.built_sql_filter != None:
        built_sql_filter = args.built_sql_filter

    # Récupération des paramètres fichiers
    if args.epsg != None:
        epsg = args.epsg
    if args.format_vector != None:
        format_vector = args.format_vector

    # Récupération des paramètres PostGIS
    if args.postgis_ip_host != None:
        postgis_ip_host = args.postgis_ip_host
    if args.postgis_num_port != None:
        postgis_num_port = args.postgis_num_port
    if args.postgis_user_name != None:
        postgis_user_name = args.postgis_user_name
    if args.postgis_password != None:
        postgis_password = args.postgis_password
    if args.postgis_database_name != None:
        postgis_database_name = args.postgis_database_name
    if args.postgis_schema_name != None:
        postgis_schema_name = args.postgis_schema_name
    if args.postgis_encoding != None:
        postgis_encoding = args.postgis_encoding

    # Récupération des paramètres généraux
    if args.path_time_log != None:
        path_time_log = args.path_time_log
    if args.save_results_intermediate != None:
        save_results_intermediate = args.save_results_intermediate
    if args.overwrite != None:
        overwrite = args.overwrite
    if args.debug != None:
        global debug
        debug = args.debug

    if os.path.isfile(output_vulnerability) and not overwrite:
        raise NameError (cyan + "UhiVulnerability: " + bold + red  + "File %s already exists, and overwrite is not activated." % output_vulnerability + endC)

    if debug >= 3:
        print('\n' + bold + green + "Vulnérabilité ICU - Variables dans le parser :" + endC)
        print(cyan + "    UhiVulnerability : " + endC + "input_division : " + str(input_division) + endC)
        print(cyan + "    UhiVulnerability : " + endC + "input_footprint : " + str(input_footprint) + endC)
        print(cyan + "    UhiVulnerability : " + endC + "input_population : " + str(input_population) + endC)
        print(cyan + "    UhiVulnerability : " + endC + "input_built : " + str(input_built) + endC)
        print(cyan + "    UhiVulnerability : " + endC + "output_vulnerability : " + str(output_vulnerability) + endC)
        print(cyan + "    UhiVulnerability : " + endC + "id_div : " + str(id_div) + endC)
        print(cyan + "    UhiVulnerability : " + endC + "id_pop : " + str(id_pop) + endC)
        print(cyan + "    UhiVulnerability : " + endC + "id_blt : " + str(id_blt) + endC)
        print(cyan + "    UhiVulnerability : " + endC + "stake_field : " + str(stake_field) + endC)
        print(cyan + "    UhiVulnerability : " + endC + "health_vuln_field_list : " + str(health_vuln_field_list) + endC)
        print(cyan + "    UhiVulnerability : " + endC + "social_vuln_field_list : " + str(social_vuln_field_list) + endC)
        print(cyan + "    UhiVulnerability : " + endC + "height_field : " + str(height_field) + endC)
        print(cyan + "    UhiVulnerability : " + endC + "built_sql_filter : " + str(built_sql_filter) + endC)
        print(cyan + "    UhiVulnerability : " + endC + "epsg : " + str(epsg) + endC)
        print(cyan + "    UhiVulnerability : " + endC + "format_vector : " + str(format_vector) + endC)
        print(cyan + "    UhiVulnerability : " + endC + "postgis_ip_host : " + str(postgis_ip_host) + endC)
        print(cyan + "    UhiVulnerability : " + endC + "postgis_num_port : " + str(postgis_num_port) + endC)
        print(cyan + "    UhiVulnerability : " + endC + "postgis_user_name : " + str(postgis_user_name) + endC)
        print(cyan + "    UhiVulnerability : " + endC + "postgis_password : " + str(postgis_password) + endC)
        print(cyan + "    UhiVulnerability : " + endC + "postgis_database_name : " + str(postgis_database_name) + endC)
        print(cyan + "    UhiVulnerability : " + endC + "postgis_schema_name : " + str(postgis_schema_name) + endC)
        print(cyan + "    UhiVulnerability : " + endC + "postgis_encoding : " + str(postgis_encoding) + endC)
        print(cyan + "    UhiVulnerability : " + endC + "path_time_log : " + str(path_time_log) + endC)
        print(cyan + "    UhiVulnerability : " + endC + "save_results_intermediate : " + str(save_results_intermediate) + endC)
        print(cyan + "    UhiVulnerability : " + endC + "overwrite : " + str(overwrite) + endC)
        print(cyan + "    UhiVulnerability : " + endC + "debug : " + str(debug) + endC + '\n')

    # Création du dossier de sortie, s'il n'existe pas
    if not os.path.isdir(os.path.dirname(output_vulnerability)):
        os.makedirs(os.path.dirname(output_vulnerability))

    # EXECUTION DES FONCTIONS
    populationVulnerability(input_division, input_footprint, input_population, input_built, output_vulnerability, id_div, id_pop, id_blt, stake_field, health_vuln_field_list, social_vuln_field_list, height_field, built_sql_filter, epsg, format_vector, postgis_ip_host, postgis_num_port, postgis_user_name, postgis_password, postgis_database_name, postgis_schema_name, postgis_encoding, path_time_log, save_results_intermediate, overwrite)

if __name__ == '__main__':
    main(gui=False)

